# PeerToPeerMessaging
1.	Introduction
In this assignment, we were required to implement a P2P messaging system with several security features.
It was written in JAVA language and we tried to handle the first six requirements that were stated in assignment document. Bonus features weren’t implemented.

Note: In order to execute the system successfully, you first need to run Server.java. Then you must execute exactly two Users.java files and enter the required inputs. (Details can be seen in section 6) 

2.	System Structures
We have two main members of our system; Server and Peer.
Server acts as a certification and authentication authority which helps the peers to authenticate and connect with each others by providing the required port numbers of other peer. 
Peer simply represents the client. He/she must be registered in order to communicate with another peer. Our system supports for just 2 peers to be connected at the same time.
Correspondingly, the system contains some several types of threads as followings: 
-	ServerThread: Handles the operations that needs to be done in Certification step.
-	PeerHandleThread: Initializes the server side of a Peer object. Generates a server socket and starts to listening the incoming connections.
-	PeerSenderThread: Handles the message sending operation of P2P messaging. In other words, sends a message from one peer to another. 
-	PeerReceiverThread: Handles the message receiving operation of P2P messaging.
-	HandshakeHandleThread: Handles the operations that needs to be done in Handshake step.
The program contains several more helper classes, the explanation of them can be found in the head of corresponding class.
3.	Running of Program and Design Explanation: 
After executed Server.java and 2 Peer.java files successfully. The input values should be entered for corresponding peers. Each peer should enter a username and a port number(port that user is going to listen the incoming connections from other peer).
There are 4 steps to be completed after input proces in order to start a communication with another peer, the progress of these steps can be seen from console output. 
•	First of all, the key pair of the peer will be generated by using generateRSAKeys function in KeyGeneratorHelper class.
•	As second step, peer will be connected to the Server in order to authenticate. The process will continue after a valid connection established between Peer and Server.
•	In third step, Peer generates an AuthenticationRequest object which contains his username, port number and public key. By using makeAuthenticationRequest function, peer sends these request to the server.
Server receives that request and tries to apply the certification step.

Certification Step : When ServerThread receives the authentication request came from a peer, the public key of the peer is extracted from that request. Since the size of an RSA key larger than another RSA key to encrypt it, the public key of peer is splitted into two and is encrypted as subparts. Then, these subparts are merged together and the encryption of public key of a peer is completed. 
   After these encryption step, the server stores that certificated(encrypted) version of public key and sends it back to the peer by creating an AuthenticationResponse object. 
(The response object also contains the public key of server.)
   At last, Peer receives incoming AuthenticationResponse object and tries to verify that certificate.

•	After certification step, authorized peer waits for another peer to be authorize and connect to him. After another successful authorization, the server informs each of the peers about the username and port number of other peer. Here, the Handshaking mechanism is started. 

Handshaking Step : Handshaking step is handled by generateHandshakeHandler function in peer, and HandshakeHandlerThread class. The server assigns a PeerStatus to the authenticated peers. The very first authenticated peer is assigned with “Initializer” and the other peer is assigned with “Target”. Here the Initializer peer represents the User1, and the Target peer represents the User2 in assignment document. The informations to transport between peers are wrapped in HandshakeStuff class.
   First of all, User1 sends a hello message together with his public key to the User2.
   Then, User2 receives that hello message, extracts and stores the public key of User1. Generates a random nonce, 
   Then, User1 receives incoming nonce and public key, stores the public key of User2, encrypts the incoming nonce with his private key, and sends back that encrypted version of nonce to the User1.
   Then, User2 receives that encrypted nonce and verifies it by decrypting with public key of User1. If the verification is valid, it sends an acknowledgment message to User1. 
   Then, User1 receives that acknowledgement message, and generates a master secret. Here the master secret is a 256 bytes symmetric AES key. After that User1 encrypts that master secret with his private key and sends it to the User2.
   Then User2 receives that encrypted master secret, decrypts it with public key of User1.
    At last, if everything goes as planned, both peer sets handshakeDone value to true and finishes the handshake step.

•	After handshaking steps, as the last step, peers must generate encryption keys, mac keys and initialization vectors by using the master secret and nonce that were generated in handshake step. In order to generate these values from the master secret and nonce, HKDF library was used. There are just one key for each direction, we didn’t generate different stuffs for two directions.
If all these steps were successfull, the program executes the PeerSenderThread and PeerReceiverThreads in order to enable users to send messages with each other. The user is prompted to input a message to send. The communication would be terminated if one of the peers enters “Q” as a message; or integrity check fails.
•	The inputted messages are encrypted before sending with the encryption key and the initialization vector that were generated previously. Except this encryption, there’s a integrity check process in order to secure the messages. The system uses HMAC to generate MAC’s. By using the plain text of the message, a HMAC is generated with the mac key of the peer before sending the message to other peer. At last, a Message object is generated that contains the encrypted version of message and HMAC and it is sended to other peer.
•	In the receiving side of the messaging system. The peer first reads the incoming Message object. Then extracts the encrypted message and HMAC. Decrypts the encrypted message to get plain text, and generate another HMAC with the same plain text message in order to verify the original HMAC. If the verification is successful, then the incoming message is printed to the console; else the system prints an information message to inform user about a malicious attack and terminates the connection.

4.	Summary of Design Choices
We tried to implement 6 different security features that were required for the programming assigment. 

-	Certification: Server acts as a certification authority by generating the certificate by using the public keys of peers. For that purpose, any other open source library wasn’t used. Server simply encrypts the public keys of peers with its private key for certification. Peers verify the certification by decrypting these certificates by using public key of server.
-	Handshaking: 
-	Key Generation: In order to generate encryption keys, mac keys and initialization vectors; HKDF library was used. It takes previously generated master key and nonce as inputs and generates the keys.
-	Message Encryption: All the messages is encrypted by using the initializaiton vector and encryption key before sending it. In order to encrypt these messages, AES method is used with CBC mode.
( See: CryptoHelper.class/encryptMessage function )
-	Integrity Check: Except the encryption of the messages, the system generates MAC’s by using the plain message text and mac keys. Here we used HMAC to generate MAC’s. 
-	Resistance To Replay Attacks: We hope that randomly generated nonces help us to avoid replay attacks. SecureRandom class was used to generate random 32 bytes nonces. Since we generate a different nonce for each of the handshake process, Trudy will not be able to generate the same encryption key, mac key and initialization vector and the system understands in the decryption of the message and checking the MAC processes whether there’s an attack comes from someone.

5.	Execution Screenshots: 
    In order to run the program, we need one Server.java and two Users.java files to be executed. First, we executed the server file. 

 
Fig1: Initial status after execution of server
Then we executed the User.java files. The program requires us to input Peer usernames and port numbers.
    
Fig2-3: Initial status after execution of peers

After we entered the inputs, the peers tries to connect to server and authenticate.
 
Fig4: Output of server while authentication process of peers

The output of authentication, handshaking and key generation process from peer’s side can be seen below.
 
Fig5: Output of peer while authentication, handshaking and key generation
After preparation processes completed, the program informs the users about conversation start and they can communicate after that step.
 
Fig6: Output of peer at the starting of the communication
